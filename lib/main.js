// Generated by CoffeeScript 2.4.1
(function() {
  "use strict";
  var CND, Multimix, alert, badge, debug, declare, echo, esc_re, help, info, isa, jr, log, rainbow, rpr, size_of, type_of, types, urge, validate, warn, whisper;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'TUNNELTEXT/MAIN';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  rainbow = CND.rainbow.bind(CND);

  ({jr} = CND);

  Multimix = require('multimix');

  //...........................................................................................................
  types = require('./types');

  ({isa, validate, declare, size_of, type_of} = types);

  //-----------------------------------------------------------------------------------------------------------
  /* from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions */
  esc_re = function(text) {
    return text.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  };

  //===========================================================================================================
  this.Tunneltext = (function() {
    class Tunneltext extends Multimix {
      // @extend   object_with_class_properties
      // @include require './cataloguing'
      // @include require './sizing'
      // @include require './declaring'

      //---------------------------------------------------------------------------------------------------------
      constructor(chrs = '\x10\x11\x12\x13\x14') {
        var idx;
        super();
        validate.tunneltext_chrs(chrs);
        this.chrs = Array.from(chrs);
        //.......................................................................................................
        this.chr_count = this.chrs.length;
        this.delta = (this.chr_count + 1) / 2 - 1;
        this.master = this.chrs[this.chr_count - this.delta - 1];
        this.meta_chr_patterns = (function() {
          var i, ref, results;
          results = [];
          for (idx = i = 0, ref = this.delta; (0 <= ref ? i <= ref : i >= ref); idx = 0 <= ref ? ++i : --i) {
            results.push(RegExp(`${esc_re(this.chrs[idx])}`, "gu"));
          }
          return results;
        }).call(this);
        this.target_seq_chrs = (function() {
          var i, ref, results;
          results = [];
          for (idx = i = 0, ref = this.delta; (0 <= ref ? i <= ref : i >= ref); idx = 0 <= ref ? ++i : --i) {
            results.push(`${this.master}${this.chrs[idx + this.delta]}`);
          }
          return results;
        }).call(this);
        this.target_seq_patterns = (function() {
          var i, ref, results;
          results = [];
          for (idx = i = 0, ref = this.delta; (0 <= ref ? i <= ref : i >= ref); idx = 0 <= ref ? ++i : --i) {
            results.push(RegExp(`${esc_re(this.target_seq_chrs[idx])}`, "gu"));
          }
          return results;
        }).call(this);
        this.cloaked = this.chrs.slice(0, this.delta);
        this.tunnels = [];
      }

      // debug 'µhd', '@delta:                ', rpr @delta
      // debug 'µhd', '@master:               ', rpr @master
      // debug 'µhd', '@meta_chr_patterns:    ', rpr @meta_chr_patterns
      // debug 'µhd', '@target_seq_chrs:      ', rpr @target_seq_chrs
      // debug 'µhd', '@target_seq_patterns:  ', rpr @target_seq_patterns
      // debug 'µhd', '@cloaked:              ', rpr @cloaked

      //---------------------------------------------------------------------------------------------------------
      hide(text) {
        var R, i, idx, j, len, ref, ref1, tunnel;
        R = text;
        for (idx = i = ref = this.delta; i >= 0; idx = i += -1) {
          R = R.replace(this.meta_chr_patterns[idx], this.target_seq_chrs[idx]);
        }
        ref1 = this.tunnels;
        for (j = 0, len = ref1.length; j < len; j++) {
          tunnel = ref1[j];
          R = tunnel.hide(R);
        }
        return R;
      }

      //---------------------------------------------------------------------------------------------------------
      reveal(text) {
        var R, i, idx, j, ref, ref1;
        R = text;
        for (idx = i = ref = this.tunnels.length - 1; i >= 0; idx = i += -1) {
          R = this.tunnels[idx].reveal(R);
        }
        for (idx = j = 0, ref1 = this.delta; j <= ref1; idx = j += +1) {
          R = R.replace(this.target_seq_patterns[idx], this.chrs[idx]);
        }
        return R;
      }

      //---------------------------------------------------------------------------------------------------------
      revert(text) {
        var R, i, idx, ref, tunnel;
        R = this.reveal(text);
        for (idx = i = ref = this.tunnels.length - 1; i >= 0; idx = i += -1) {
          if ((tunnel = this.tunnels[idx]).remove == null) {
            continue;
          }
          R = tunnel.remove(R);
        }
        return R;
      }

      //---------------------------------------------------------------------------------------------------------
      store(x) {
        var R;
        if ((R = this._index[x]) != null) {
          return R;
        }
        R = this._cache.length;
        this._index[x] = R;
        this._cache.push(x);
        return R;
      }

      //---------------------------------------------------------------------------------------------------------
      retrieve(idx) {
        if (!((idx >= 0) && (idx < this._cache.length))) {
          throw new Error(`µ44292 index out of bounds, got ${rpr(idx)}`);
        }
        return this._cache[idx];
      }

      //---------------------------------------------------------------------------------------------------------
      add_tunnel(tunnel_factory) {
        var tunnel;
        validate.tunneltext_tunnel_factory(tunnel_factory);
        validate.tunneltext_tunnel((tunnel = tunnel_factory(this)));
        return this.tunnels.push(tunnel);
      }

    };

    //---------------------------------------------------------------------------------------------------------
    Tunneltext.prototype._cache = [];

    Tunneltext.prototype._index = {};

    return Tunneltext;

  }).call(this);

  //-----------------------------------------------------------------------------------------------------------
  /* TAINT either abolish tunnel letter (`B` in this case) or pass it in as argument */
  this.tunnels = {
    'backslash': function(tnl) {
      /* `oc`: 'original character' */
      /* `op`: 'original pattern' */
      /* `rm`: 'remove' */
      var _mcp_backslash, _oc_backslash, _oce_backslash, _rm_backslash, _tsp_backslash, base, cloaked, hide, remove, reveal, start_chr, stop_chr;
      ({cloaked} = tnl);
      if (cloaked.length < 2) {
        start_chr = stop_chr = cloaked[0];
      } else {
        [start_chr, stop_chr] = cloaked;
      }
      base = 10;
      _oc_backslash = '\\';
      _oce_backslash = esc_re(_oc_backslash);
      _mcp_backslash = RegExp(`${esc_re(_oc_backslash)}(.)`, "gu");
      _tsp_backslash = RegExp(`${esc_re(start_chr)}B([0-9a-z]+)${esc_re(stop_chr)}`, "gu");
      _rm_backslash = RegExp(`${esc_re(_oc_backslash)}(.)`, "gu");
      //---------------------------------------------------------------------------------------------------------
      hide = (text) => {
        var R;
        R = text;
        R = R.replace(_mcp_backslash, function(_, $1) {
          var cid_txt;
          cid_txt = ($1.codePointAt(0)).toString(base);
          return `${start_chr}B${cid_txt}${stop_chr}`;
        });
        return R;
      };
      //.........................................................................................................
      reveal = (text) => {
        var R;
        R = text;
        R = R.replace(_tsp_backslash, function(_, $1) {
          var chr;
          chr = String.fromCodePoint(parseInt($1, base));
          return `${_oc_backslash}${chr}`;
        });
        return R;
      };
      //.........................................................................................................
      remove = (text) => {
        return text.replace(_rm_backslash, '$1');
      };
      return {
        //---------------------------------------------------------------------------------------------------------
        name: 'backslash',
        hide,
        reveal,
        remove
      };
    },
    //-----------------------------------------------------------------------------------------------------------
    htmlish: function(tnl) {
      var cloaked, hide, hide_tag_pattern, reveal, reveal_tag_pattern, start_chr, stop_chr;
      ({cloaked} = tnl);
      if (cloaked.length < 2) {
        start_chr = stop_chr = cloaked[0];
      } else {
        [start_chr, stop_chr] = cloaked;
      }
      hide_tag_pattern = /(<[^>]*?>)/gu;
      reveal_tag_pattern = RegExp(`${esc_re(start_chr)}T([0-9]+)${esc_re(stop_chr)}`, "gu");
      //---------------------------------------------------------------------------------------------------------
      hide = (text) => {
        var R;
        R = text;
        R = R.replace(hide_tag_pattern, (_, $1) => {
          var cache_idx;
          cache_idx = tnl.store($1);
          return `${start_chr}T${cache_idx}${stop_chr}`;
        });
        return R;
      };
      //.........................................................................................................
      reveal = (text) => {
        return text.replace(reveal_tag_pattern, (_, $1) => {
          return tnl.retrieve(parseInt($1, 10));
        });
      };
      return {
        //---------------------------------------------------------------------------------------------------------
        name: 'backslash',
        hide,
        reveal
      };
    }
  };

}).call(this);

//# sourceMappingURL=main.js.map
